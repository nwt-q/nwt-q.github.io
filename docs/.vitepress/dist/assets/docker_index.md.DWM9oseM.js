import{_ as i,C as r,c as l,o as p,j as a,G as o,a8 as e,a as t}from"./chunks/framework.DMZhn_gK.js";const c="/assets/image-20251209140132193.BfZV_xx2.png",d="/assets/image-20251210074734018.BVCksA7L.png",k="/assets/image-20251210074754473.C7pC16j4.png",h="/assets/image-20251210074846775.BqahHuuf.png",g="/assets/image-20251210075125393.BH-Qu6kk.png",m="/assets/image-20251210075205837.BvK2Rgwo.png",b="/assets/image-20251210075252253.DEgkz4Ut.png",u="/assets/image-20251210075317849.DptDai7C.png",E="/assets/image-20251208135955628.lCr03Loo.png",y="/assets/image-20251209140807047.Ck1A91gP.png",_="/assets/image-20251209140835793.DImQnCEc.png",C="/assets/image-20251209140939904.Bo8vx3vF.png",v="/assets/image-20251209140521292.DyYoDfRq.png",D="/assets/image-20251209140617266.DVP27zy5.png",A=JSON.parse('{"title":"docker 优质资源整合","description":"","frontmatter":{},"headers":[],"relativePath":"docker/index.md","filePath":"docker/index.md","lastUpdated":1765426912000}'),f={name:"docker/index.md"};function w(F,s,q,x,B,P){const n=r("ArticleMetadata");return p(),l("div",null,[s[0]||(s[0]=a("h1",{id:"docker-优质资源整合",tabindex:"-1"},[t("docker 优质资源整合 "),a("a",{class:"header-anchor",href:"#docker-优质资源整合","aria-label":'Permalink to "docker 优质资源整合"'},"​")],-1)),o(n),s[1]||(s[1]=a("iframe",{style:{width:"100%","aspect-ratio":"16/9","margin-top":"2em"},src:"//player.bilibili.com/player.html?bvid=BV1THKyzBER6&autoplay=0&loop=0",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1)),s[2]||(s[2]=e('<h2 id="docker-的安装" tabindex="-1">docker 的安装 <a class="header-anchor" href="#docker-的安装" aria-label="Permalink to &quot;docker 的安装&quot;">​</a></h2><p><img src="'+c+'" alt="image-20251209140132193" loading="lazy"></p><p>Windows中安装docker</p><p>个人觉得在windows中使用docker能够像管理应用般管理系统内部的环境不会造成环境冲突等情况，唯一的劣势可能便是需要多环境联动编译的时候使用docker会造成系统储存空间进一减低</p><p>根据教程先 <code>wsl install</code> Windows中 Linux的环境， 通过此环境编译代码等操作。</p><p>参考文档： <a href="https://www.cnblogs.com/littleatp/p/18810739" target="_blank" rel="noreferrer">【保姆级教程】windows 安装 docker 全流程 - 美码师 - 博客园</a></p><h2 id="docker常用命令" tabindex="-1">docker常用命令 <a class="header-anchor" href="#docker常用命令" aria-label="Permalink to &quot;docker常用命令&quot;">​</a></h2><ul><li><p>docker pull 拉取镜像</p></li><li><p>docker images 查看本地镜像</p></li><li><p>docker pull --platform=xxxx 镜像名 拉取特定架构镜像</p></li><li><p>docker run 运行镜像</p></li><li><p>docker volume list 列出所有卷</p></li><li><p>docker create 只创建镜像不启动</p></li><li><p>docker start 启动容器</p></li><li><p>docker exec [容器id] 进入容器内部查看运行情况</p></li><li><p>docker run nginx -d -d 代表 分离模式 后台运行不阻塞当前窗口</p></li><li><p>-p 表示宿主机的端口与容器内的端口进行绑定</p></li><li><p>-a 查看所有容器</p></li><li><p>-v 宿主机目录：容器目录</p></li><li><p>-e 传递环境变量</p></li><li><p>-it 进入容器内部</p></li><li><p>-- rm 当容器停止时删除容器</p></li><li><p>-- restart always (unless-stopped) 自动从重启</p></li></ul><p>删除容器</p><p><img src="'+d+'" alt="image-20251210074734018" loading="lazy"></p><p>创建数据卷和查看所在数据卷的实际位置</p><p><img src="'+k+'" alt="image-20251210074754473" loading="lazy"></p><p>可能出现下面的情况： 数据卷的实际位置无法找到请查看<a href="./FindVolumes.html">Docker 数据卷访问失败</a></p><p><img src="'+h+'" alt="image-20251210074846775" loading="lazy"></p><p>删除数据卷的时候需要停止对数据卷的使用</p><p><img src="'+g+'" alt="image-20251210075125393" loading="lazy"></p><p>删除掉未使用的数据卷</p><p><img src="'+m+'" alt="image-20251210075205837" loading="lazy"></p><p>运行容器</p><p><img src="'+b+'" alt="image-20251210075252253" loading="lazy"></p><p>查看容器所有信息命令</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> inspect</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 3f41e197b700</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">容器id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><img src="'+u+'" alt="image-20251210075317849" loading="lazy"></p><p>查看进程</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ps</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ef</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>绑定挂载与挂载卷挂载</p><p><img src="'+E+`" alt="image-20251208135955628" loading="lazy"></p><h2 id="挂载卷" tabindex="-1">挂载卷 <a class="header-anchor" href="#挂载卷" aria-label="Permalink to &quot;挂载卷&quot;">​</a></h2><h2 id="制作docker容器" tabindex="-1">制作docker容器 <a class="header-anchor" href="#制作docker容器" aria-label="Permalink to &quot;制作docker容器&quot;">​</a></h2><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> wearth_mcp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="创建子网" tabindex="-1">创建子网 <a class="header-anchor" href="#创建子网" aria-label="Permalink to &quot;创建子网&quot;">​</a></h2><ul><li>docker network create network1</li></ul><p>同一个子网的容器相互间可以相互通信</p><p>docker内部的dns机制可以通过容器名访问容器</p><h3 id="桥接模式" tabindex="-1">桥接模式 <a class="header-anchor" href="#桥接模式" aria-label="Permalink to &quot;桥接模式&quot;">​</a></h3><h3 id="host模式" tabindex="-1">host模式 <a class="header-anchor" href="#host模式" aria-label="Permalink to &quot;host模式&quot;">​</a></h3><h3 id="none模式" tabindex="-1">None模式 <a class="header-anchor" href="#none模式" aria-label="Permalink to &quot;None模式&quot;">​</a></h3><h2 id="docker-compose" tabindex="-1">Docker Compose <a class="header-anchor" href="#docker-compose" aria-label="Permalink to &quot;Docker Compose&quot;">​</a></h2><p>我们现在知道了 Docker 容器 本身只是<strong>一个</strong>特殊进程，但如果我想要部署<strong>多个</strong>容器，且对这些容器的顺序有一定要求呢？比如一个博客系统，当然是先启动数据库，再启动身份验证服务，最后才能启动博客 web 服务。按理说挨个执行 docker run 命令当然是没问题的，但有没有更优雅的解决方案？有。我们可以通过一个 <strong>YAML</strong> 文件写清楚要部署的<strong>容器有哪些</strong>，<strong>部署顺序</strong>是怎么样的，以及这些容器占用的 <strong>cpu 和内存</strong>等信息。通过这个文件启动定义的所有容器</p><ul><li>docker compose up -d</li></ul><div class="language-dockerfile vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">version: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.8&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">services:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    image: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;some-image-for-a&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deploy:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      resources:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        limits:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          cpus: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0.50&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> # 限制 CPU 使用率为 50%</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          memory: 256M # 限制内存使用量为 256MB</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  B:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    image: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;some-image-for-b&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    depends_on:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - A</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    image: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;some-image-for-c&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    depends_on:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      - B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>然后，通过一行<code>Docker-compose up</code>命令，开始解析 YAML 文件，将容器们一键按顺序部署，就完成<strong>一整套服务</strong>的部署。这其实就是 <strong>Docker Compose</strong> 干的事情</p><h2 id="docker-swarm" tabindex="-1">docker Swarm <a class="header-anchor" href="#docker-swarm" aria-label="Permalink to &quot;docker Swarm&quot;">​</a></h2><p>Docker 解决的是<strong>一个容器</strong>的部署。Docker Compose 解决的是<strong>多个容器组成的一整套服务</strong>的部署。那 Docker Swarm 就更高维度了，它解决的其实是这一整套服务<strong>在多台服务器上的集群部署</strong>问题。比如在 A 服务器坏了，就将服务在 B 服务器上重新部署一套，实现迁移，还能根据需要对服务做扩缩容。</p><p><img src="`+y+'" alt="image-20251209140807047" loading="lazy"></p><h2 id="docker-与-kubernetes-k8s-的关系" tabindex="-1">Docker 与 Kubernetes(k8s) 的关系 <a class="header-anchor" href="#docker-与-kubernetes-k8s-的关系" aria-label="Permalink to &quot;Docker 与 Kubernetes(k8s) 的关系&quot;">​</a></h2>',46)),s[3]||(s[3]=a("iframe",{style:{width:"100%","aspect-ratio":"16/9","margin-top":"2em"},src:"//player.bilibili.com/player.html?bvid=BV1aA4m1w7Ew&autoplay=0&loop=0",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:""},null,-1)),s[4]||(s[4]=e(`<p>本文一下内容主要解决下面的问题</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker是什么？</span></span>
<span class="line"><span>docker架构原理？</span></span>
<span class="line"><span>docker的命令基础</span></span>
<span class="line"><span>docker容器和虚拟机有什么区别？</span></span>
<span class="line"><span>docker compose是什么？</span></span>
<span class="line"><span>docker swarm是什么？</span></span>
<span class="line"><span>docker compose和docker swarm的区别是什么？</span></span>
<span class="line"><span>docker和kubernetes(k8s)的关系是什么？</span></span>
<span class="line"><span>docker swarm和kubernetes(k8s)的差异是什么？</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>k8s 会在多台 Node 服务器上调度 Pod，进行部署和扩缩容。</p><p><img src="`+_+'" alt="image-20251209140835793" loading="lazy"></p><p>每个 Pod 内部可以含有多个 container，每个 container 本质上就是一个服务进程。</p><p>是不是感觉<strong>k8s</strong>跟 <strong>Docker Swarm</strong> 做的事情很像？没错，其实 Docker Swarm 是 k8s 的<strong>竞品</strong>，既然是竞品，那它们做的事情其实区别就不大了。现在回过头来看 Docker 容器和 k8s 之间的关系，思路就清晰了。Docker 部署的<strong>容器</strong>，其实就是 k8s 调度的 Pod 里的 <strong>container</strong>，它们都叫<strong>容器</strong>，其实是一回事。只不过 k8s 除了支持 Docker 的容器外，还支持别人家的容器。Docker Compose 基于多个 container 创建的<strong>一整套服务</strong>，其实就是 k8s 里的 <strong>pod</strong>。而 Docker Swarm 做的事情和 k8s 一样，本质上就是在调度 pod。回过头来看下 k8s 的官方定义，叫容器编排引擎，将它理解为，以 API <strong>编</strong>程的方式管理安<strong>排</strong>各个容器的引擎，是不是就特别精辟。</p><p><img src="'+C+'" alt="image-20251209140939904" loading="lazy"></p><h2 id="docker的架构原理" tabindex="-1">docker的架构原理 <a class="header-anchor" href="#docker的架构原理" aria-label="Permalink to &quot;docker的架构原理&quot;">​</a></h2><p>docker是经典的Cline/Serve 架构</p><p>Client 对应 Docker-cli， Server 对应 Docker daemon。我们在命令行里敲 Docker 命令，使用的就是 Docker-cli.</p><p><img src="'+v+'" alt="docker是C/S架构" loading="lazy"></p><p>Docker-cli 会解析我们输入的 cmd 命令，然后调用 Docker daemon 守护进程提供的 RESTful API，守护进程收到命令后，会根据指令创建和管理各个容器。再具体点，Docker Daemon 内部分为 Docker Server、Engine 两层。<code>Docker Server 本质上就是个 HTTP 服务，负责对外提供操作容器和镜像的 api 接口，接收到 API 请求后，会分发任务给 Engine 层，Engine 层负责创建 Job，由 Job 实际执行各种工作。</code></p><p><img src="'+D+'" alt="image-20251209140617266" loading="lazy"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>• Docker 本质上就是一个将<strong>程序和环境打包并运行</strong>的工具软件，而 Docker 容器本质上只是个自带独立运行环境的<strong>特殊进程</strong>，底层用的其实是<strong>宿主机的操作系统内核</strong>。</li><li>• Docker 软件 通过 Dockerfile 描述环境和应用程序的依赖关系， docker build 构建镜像， docker pull/push 跟 Docker Registry 交互实现存储和分发镜像，docker run 命令基于镜像启动容器，基于容器技术运行程序和它对应的环境，从而解决环境依赖导致的各种问题。</li><li>• Docker 解决的是<strong>一个容器</strong>的部署问题，Docker Compose 解决的是<strong>多个容器组成的一套服务</strong>的部署问题，Docker Swarm 解决的是多个容器组成的<strong>一套服务在多台服务器上的部署问题</strong>，k8s 则是 Docker Swarm 的竞品，在更高维度上<strong>兼容</strong>了 Docker 容器，实现了容器编排调度。</li></ul><p>参考文章： <a href="https://mp.weixin.qq.com/s/_ldWjMNgyAsglGexSbsqEw" target="_blank" rel="noreferrer">Docker 是什么？ 和 k8s 之间是什么关系？</a></p><p><a href="https://blog.csdn.net/a2875254060/article/details/142468037" target="_blank" rel="noreferrer">一文彻底搞懂大模型 - RAG（检索、增强、生成）-CSDN博客</a></p>',17))])}const z=i(f,[["render",w]]);export{A as __pageData,z as default};
